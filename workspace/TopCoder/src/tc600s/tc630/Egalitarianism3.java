package tc600s.tc630;
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class Egalitarianism3
{
	final int INF = 1<<20;
	public int maxCities(int n, int[] a, int[] b, int[] len)
	{
		if (n == 1) return 1;
		int[][] d = new int[n][n];
		for(int i=0; i<d.length; i++) Arrays.fill(d[i],INF);
		
		for (int i=0; i<n-1; i++) {
			d[a[i]-1][b[i]-1] = len[i];
			d[b[i]-1][a[i]-1] = len[i];
		}
		for (int i=0; i<n; i++) {
			d[i][i] = 0;
		}
		
		for (int k=0; k<n; k++) {
			for (int i=0; i<n; i++) {
				for (int j=0; j<n; j++) {
					d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);
				}
			}
		}
		
		int ret = 2;
		for (int i=0; i<n; i++) {
			Map<Integer, List<Integer>> map = new HashMap<>(); //<distance, points>
			for (int j=0; j<n; j++) {
				if (j==i) continue;
				if (!map.containsKey(d[i][j])) {
					List<Integer> list = new ArrayList<>();
					list.add(j);
					map.put(d[i][j], list);
					continue;
				}
				List<Integer> list = map.get(d[i][j]);
				boolean good = true;
				for (int k : list) {
					if (d[j][k] != 2*d[j][i]) {
						good = false;
					}
				}
				if (good) {
					list.add(j);
//					map.put(d[i][j], list);
				}
			}
			for (int key : map.keySet()) {
				ret = Math.max(ret, map.get(key).size());
			}
		}
		return ret;
		
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit-pf 2.3.0
	private static boolean KawigiEdit_RunTest(int testNum, int p0, int[] p1, int[] p2, int[] p3, boolean hasAnswer, int p4) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p1[i]);
		}
		System.out.print("}" + "," + "{");
		for (int i = 0; p2.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p2[i]);
		}
		System.out.print("}" + "," + "{");
		for (int i = 0; p3.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p3[i]);
		}
		System.out.print("}");
		System.out.println("]");
		Egalitarianism3 obj;
		int answer;
		obj = new Egalitarianism3();
		long startTime = System.currentTimeMillis();
		answer = obj.maxCities(p0, p1, p2, p3);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p4);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p4;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		boolean disabled;
		boolean tests_disabled;
		all_right = true;
		tests_disabled = false;
		
		int p0;
		int[] p1;
		int[] p2;
		int[] p3;
		int p4;
		
		// ----- test 0 -----
		disabled = false;
		p0 = 4;
		p1 = new int[]{1,1,1};
		p2 = new int[]{2,3,4};
		p3 = new int[]{1,1,1};
		p4 = 3;
		all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 1 -----
		disabled = false;
		p0 = 6;
		p1 = new int[]{1,2,3,2,3};
		p2 = new int[]{2,3,4,5,6};
		p3 = new int[]{2,1,3,2,3};
		p4 = 3;
		all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 2 -----
		disabled = false;
		p0 = 10;
		p1 = new int[]{1,1,1,1,1,1,1,1,1};
		p2 = new int[]{2,3,4,5,6,7,8,9,10};
		p3 = new int[]{1000,1000,1000,1000,1000,1000,1000,1000,1000};
		p4 = 9;
		all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 3 -----
		disabled = false;
		p0 = 1;
		p1 = new int[]{};
		p2 = new int[]{};
		p3 = new int[]{};
		p4 = 1;
		all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 4 -----
		disabled = false;
		p0 = 43;
		p1 = new int[]{7, 19, 7, 21, 10, 14, 25, 40, 14, 2, 10, 14, 7, 30, 18, 23, 30, 26, 17, 5, 30, 16, 30, 7, 7, 14, 25, 5, 31, 40, 14, 24, 13, 17, 9, 7, 42, 25, 2, 30, 43, 30};
		p2 = new int[]{9, 13, 40, 19, 3, 6, 31, 30, 24, 28, 33, 27, 1, 23, 8, 2, 5, 42, 26, 17, 15, 20, 25, 36, 14, 38, 12, 22, 37, 16, 18, 41, 32, 39, 10, 29, 35, 21, 34, 43, 4, 11};
		p3 = new int[]{10, 10, 6, 1, 7, 6, 8, 6, 2, 6, 7, 4, 1, 4, 5, 2, 4, 5, 5, 3, 1, 2, 2, 4, 5, 5, 2, 4, 10, 3, 10, 8, 4, 7, 10, 5, 1, 1, 7, 9, 5, 8};
		p4 = 3;
		all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		if (all_right) {
			if (tests_disabled) {
				System.out.println("You're a stud (but some test cases were disabled)!");
			} else {
				System.out.println("You're a stud (at least on given cases)!");
			}
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// In Treeland there are n cities, numbered 1 through n.
	// The cities are linked by n-1 bidirectional roads.
	// Each road connects a pair of cities.
	// The roads are built in such a way that each city is reachable from each other city by roads.
	// (In other words, the topology of the road network is a tree.)
	// 
	// 
	// You are given the int n and three int[]s that describe the road network: a, b, and len.
	// For each i between 0 and n-2, inclusive, there is a road of length len[i] that connects the cities a[i] and b[i].
	// 
	// 
	// The distance between two cities is the sum of lengths of roads on the sequence of roads that connects them. (Note that this sequence of roads is always unique.)
	// 
	// 
	// You want to select k cities in such a way that all pairwise distances between the selected cities are the same.
	// In other words, there must be a distance d such that the distance between every two selected cities is d.
	// Return the largest possible value of k for which this is possible.
	// 
	// 
	// DEFINITION
	// Class:Egalitarianism3
	// Method:maxCities
	// Parameters:int, int[], int[], int[]
	// Returns:int
	// Method signature:int maxCities(int n, int[] a, int[] b, int[] len)
	// 
	// 
	// CONSTRAINTS
	// -n will be between 1 and 50, inclusive.
	// -a will contain exactly n-1 elements.
	// -b will contain exactly n-1 elements.
	// -len will contain exactly n-1 elements.
	// -Each element in a will be between 1 and n, inclusive.
	// -Each element in b will be between 1 and n, inclusive.
	// -Each element in len will be between 1 and 1,000, inclusive.
	// -The graph described by a and b will be a tree.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 4
	// {1,1,1}
	// {2,3,4}
	// {1,1,1}
	// 
	// Returns: 3
	// 
	// There are 4 cities and 3 roads, each of length 1.
	// The roads connect the following pairs of cities: (1,2), (1,3), and (1,4).
	// The optimal answer is k=3.
	// We can select three cities in the required way: we select the cities {2, 3, 4}.
	// The distance between any two of these cities is 2.
	// 
	// 1)
	// 6
	// {1,2,3,2,3}
	// {2,3,4,5,6}
	// {2,1,3,2,3}
	// 
	// Returns: 3
	// 
	// Again, the largest possible k is 3.
	// There are two ways to select three equidistant cities: {1, 4, 6} and {4, 5, 6}.
	// (In both cases the common distance is 6.)
	// 
	// 2)
	// 10
	// {1,1,1,1,1,1,1,1,1}
	// {2,3,4,5,6,7,8,9,10}
	// {1000,1000,1000,1000,1000,1000,1000,1000,1000}
	// 
	// Returns: 9
	// 
	// 
	// 
	// 3)
	// 1
	// {}
	// {}
	// {}
	// 
	// Returns: 1
	// 
	// Note that n can be 1.
	// 
	// END KAWIGIEDIT TESTING
}

//Powered by KawigiEdit-pf 2.3.0!
