package tc600s.tc636;
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class ChocolateDividingEasy
{
	final int CHARTOINT = 48;
	
	public int findBest(String[] chocolate)
	{
		int vlen = chocolate.length;
		int hlen = chocolate[0].length();
		
		// precalculate
		int[][] cum = new int[vlen][hlen];
		for (int i=0; i<vlen; i++) {
			int htotal = 0;
			for (int j=0; j<hlen; j++) {
				htotal += (int) chocolate[i].charAt(j) - CHARTOINT;
				cum[i][j] += htotal;

				if (i != 0) {
					cum[i][j] += cum[i-1][j];
				}
			}
		}
		
		// every cut
		int max = 0;
		for (int i=0; i<vlen-1; i++) {
			for (int j=i+1; j<vlen-1; j++) {
				for (int k=0; k<hlen-1; k++) {
					for(int l=k+1; l<hlen-1; l++) {
						int tl = cum[i][k];
						int tm = cum[i][l] - tl;
						int tr = cum[i][hlen-1] - tm - tl;
						int ml = cum[j][k] - tl;
						int mm = cum[j][l] - tl - tm - ml;
						int mr = cum[j][hlen-1] - tl - tm - tr - ml - mm;
						int bl = cum[vlen-1][k] - tl - ml;
						int bm = cum[vlen-1][l] - tl - ml - bl - tm - mm;
						int br = cum[vlen-1][hlen-1] - tl - tm - tr - ml - mm - mr - bl - bm;

						int min =  tl;
						min = Math.min(min, tm);
						min = Math.min(min, tr);
						min = Math.min(min, ml);
						min = Math.min(min, mm);
						min = Math.min(min, mr);
						min = Math.min(min, bl);
						min = Math.min(min, bm);
						min = Math.min(min, br);
						max = Math.max(max, min);
					}
				}
			}
		}
		
		return max;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit-pf 2.3.0
	private static boolean KawigiEdit_RunTest(int testNum, String[] p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print("\"" + p0[i] + "\"");
		}
		System.out.print("}");
		System.out.println("]");
		ChocolateDividingEasy obj;
		int answer;
		obj = new ChocolateDividingEasy();
		long startTime = System.currentTimeMillis();
		answer = obj.findBest(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		boolean disabled;
		boolean tests_disabled;
		all_right = true;
		tests_disabled = false;
		
		String[] p0;
		int p1;
		
		// ----- test 0 -----
		disabled = false;
		p0 = new String[]{"9768","6767","5313"};
		p1 = 3;
		all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 1 -----
		disabled = false;
		p0 = new String[]{"36753562","91270936","06261879","20237592","28973612","93194784"};
		p1 = 15;
		all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 2 -----
		disabled = false;
		p0 = new String[]{"012","345","678"};
		p1 = 0;
		all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		if (all_right) {
			if (tests_disabled) {
				System.out.println("You're a stud (but some test cases were disabled)!");
			} else {
				System.out.println("You're a stud (at least on given cases)!");
			}
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Mirosz adores sweets.
	// He has just bought a rectangular bar of chocolate.
	// The bar is divided into a grid of square cells.
	// Different cells may have a different quality.
	// You are given the description of the bar in a String[] chocolate.
	// Each character in chocolate is a digit between '0' and '9', inclusive: the quality of one of the cells.
	// 
	// Mirosz is now going to divide the chocolate into 9 parts: one for him and one for each of his 8 friends.
	// He will do the division by making four cuts: two horizontal and two vertical ones.
	// Each cut must go between two rows or columns of cells.
	// Each of the 9 parts must be non-empty.
	// The quality of a part is the sum of the qualities of all cells it contains.
	// 
	// Mirosz is well-mannered and he will let his friends choose their pieces first.
	// His friends are even more addicted to chocolate than he is.
	// Therefore, they will certainly choose the pieces with higher quality first, and Mirosz will be left with the worst of the nine pieces.
	// 
	// You are given the String[] chocolate.
	// Find the optimal places for the four cuts.
	// More precisely, compute and return the largest possible quality of Mirosz's part of the chocolate bar.
	// 
	// DEFINITION
	// Class:ChocolateDividingEasy
	// Method:findBest
	// Parameters:String[]
	// Returns:int
	// Method signature:int findBest(String[] chocolate)
	// 
	// 
	// CONSTRAINTS
	// -chocolate will contain between 3 and 50 elements, inclusive. 
	// -All elements in chocolate will contain between 3 and 50 characters, inclusive. 
	// -All elements in chocolate will contain the same number of characters. 
	// -All elements in chocolate will contain only digits ('0'-'9').
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {
	// "9768",
	// "6767",
	// "5313"
	// }
	// 
	// Returns: 3
	// 
	// There are three valid ways to cut this chocolate.
	// One of the optimal ones is shown below. 
	// 
	// 9 | 7 | 6 8 
	// --|---|----- 
	// 6 | 7 | 6 7 
	// --|---|----- 
	// 5 | 3 | 1 3 
	// 
	// This way of cutting produces parts with the following qualities:
	// 9, 7, 14, 6, 7, 13, 5, 3, and 4.
	// The quality of the worst part (the one that Mirosz will get) is 3. 
	// 
	// Here is another way of cutting the same chocolate: 
	// 
	// 
	// 9 7 | 6 | 8 
	// ----|---|--- 
	// 6 7 | 6 | 7 
	// ----|---|--- 
	// 5 3 | 1 | 3 
	// 
	// 
	// If Mirosz cuts the chocolate in this way, the quality of his part will be 1, which is worse than 3.
	// 
	// 1)
	// {
	// "36753562",
	// "91270936",
	// "06261879",
	// "20237592",
	// "28973612",
	// "93194784"
	// }
	// 
	// Returns: 15
	// 
	// There is only one optimal way to divide the chocolate:  
	// 
	// 
	// 3 6 7 5 | 3 5 | 6 2 
	// 9 1 2 7 | 0 9 | 3 6 
	// --------|-----|----- 
	// 0 6 2 6 | 1 8 | 7 9 
	// 2 0 2 3 | 7 5 | 9 2 
	// --------|-----|----- 
	// 2 8 9 7 | 3 6 | 1 2 
	// 9 3 1 9 | 4 7 | 8 4  
	// 
	// The three parts on the top have qualities 3+6+7+5+9+1+2+7 = 40, 3+5+0+9 = 17 and 6+2+3+6 = 17 
	// The worst part is the one in the bottom right corner. Its quality is only 1+2+4+8 = 15.
	// 
	// 2)
	// {
	// "012",
	// "345",
	// "678"
	// }
	// 
	// Returns: 0
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}

//Powered by KawigiEdit-pf 2.3.0!
