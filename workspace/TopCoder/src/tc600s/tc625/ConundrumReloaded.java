package tc600s.tc625;
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class ConundrumReloaded
{
	public int minimumLiars(String answers)
	{
		int len = answers.length();
		int qindex = -1;
		StringBuilder sb = new StringBuilder();
		int ret = 0;
		for (int i = 0; i < len; i++) {
			if (qindex == -1) {
				if (answers.charAt(i) == '?') qindex = i;
				continue;
			}
			sb.append(answers.charAt(i));
			if (answers.charAt(i) == '?') {
				ret += getMin(sb.toString());
				sb = new StringBuilder();
			}
		}
		if (qindex == -1) {
			ret = getMin(answers);
			return ret == Integer.MAX_VALUE ? -1 : ret;
		}
		for (int i = 0; i <= qindex; i++) {
			sb.append(answers.charAt(i));
			if (answers.charAt(i) == '?') {
				ret += getMin(sb.toString());
				sb = new StringBuilder();
			}
		}
		ret += getMin(sb.toString());
		return ret;
	}
	
	public int getMin(String str) {
		if ("".equals(str) || "?".equals(str)) return 0;

		//first is honest
		int ret = simulate(str, true);
		//first is liar
		ret = Math.min(ret, simulate(str,false));
		return ret;
	}
	
	public int simulate(String str, boolean firstIsH) {
		int len = str.length();
		int ret = 0;
		boolean isH = firstIsH;
		if (!isH) ret++;
		int loop = len;
		if (str.charAt(len - 1) == '?') loop--;
		
		for (int i = 0; i < loop; i++) {
			if (isH) {
				if (str.charAt(i) == 'L') {
					isH = false;
					ret++;
				} else {
					isH = true;
				}
			} else {
				if (str.charAt(i) == 'H') {
					isH = false;
					ret++;
				} else {
					isH = true;
				}
			}
		}
		if (str.charAt(len - 1) != '?') {
			if (isH && !firstIsH) return Integer.MAX_VALUE;
			if (!isH && firstIsH) return Integer.MAX_VALUE;
			if (!isH && !firstIsH) ret--;
		}
		
		return ret;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit-pf 2.3.0
	private static boolean KawigiEdit_RunTest(int testNum, String p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "\"" + p0 + "\"");
		System.out.println("]");
		ConundrumReloaded obj;
		int answer;
		obj = new ConundrumReloaded();
		long startTime = System.currentTimeMillis();
		answer = obj.minimumLiars(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		boolean disabled;
		boolean tests_disabled;
		all_right = true;
		tests_disabled = false;
		
		String p0;
		int p1;
		
		// ----- test 0 -----
		disabled = false;
		p0 = "LLH";
		p1 = 1;
		all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 1 -----
		disabled = false;
		p0 = "?????";
		p1 = 0;
		all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 2 -----
		disabled = false;
		p0 = "LHLH?";
		p1 = 2;
		all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 3 -----
		disabled = false;
		p0 = "??LLLLLL??";
		p1 = 3;
		all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 4 -----
		disabled = false;
		p0 = "LLL";
		p1 = -1;
		all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 4 -----
		disabled = false;
		p0 = "LHL";
		p1 = 1;
		all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		if (all_right) {
			if (tests_disabled) {
				System.out.println("You're a stud (but some test cases were disabled)!");
			} else {
				System.out.println("You're a stud (at least on given cases)!");
			}
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Once upon a time, N people sat around a circle. They were numbered 0 through N-1 in counter-clockwise order. Each person was either a honest person or a liar. A honest person always tells the truth, a liar always lies. You asked some of them (possibly all or none) whether the person sitting to the right of them is a liar. You are given their answers in a String answers with N characters. For each i, character i of answers is one of the following:
	// 
	// 
	// 'L' if person i said that person (i+1) is a liar,
	// 'H' if person i said that person (i+1) is a honest person,
	// '?' if you didn't ask person i.
	// 
	// (Above, (i+1) is considered modulo N. That is, person N-1 is talking about person 0.)
	// 
	// You are given the String answers. If there is at least one possible combination of honest people and liars that is consistent with answers, return the smallest possible number of liars. Else return -1.
	// 
	// DEFINITION
	// Class:ConundrumReloaded
	// Method:minimumLiars
	// Parameters:String
	// Returns:int
	// Method signature:int minimumLiars(String answers)
	// 
	// 
	// CONSTRAINTS
	// -answers will contain between 2 and 50 characters, inclusive.
	// -Each character in answers will be 'L', 'H' or '?'.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// "LLH"
	// 
	// Returns: 1
	// 
	// According to the input:
	// 
	// Person 0 says that person 1 is a liar.
	// Person 1 says that person 2 is a liar.
	// Person 2 says that person 0 is a honest person.
	// 
	// Clearly, they cannot all be honest, so there is at least one liar. It is possible that person 1 is liar and the other two are honest. Hence, the smallest possible number of liars is one.
	// 
	// (Note that it is also possible that person 1 is honest and the other two are liars.)
	// 
	// 1)
	// "?????"
	// 
	// Returns: 0
	// 
	// Nobody told us anything. It is possible that everybody is honest.
	// 
	// 2)
	// "LHLH?"
	// 
	// Returns: 2
	// 
	// If person #1 and person #2 are liars, then the answers would be "LHLHH". This is consistent with the answers we received.
	// 
	// 3)
	// "??LLLLLL??"
	// 
	// Returns: 3
	// 
	// 
	// 
	// 4)
	// "LLL"
	// 
	// Returns: -1
	// 
	// Each of the 8 possible combinations of (liar / honest person) will lead to a contradiction.
	// 
	// END KAWIGIEDIT TESTING
}

//Powered by KawigiEdit-pf 2.3.0!
