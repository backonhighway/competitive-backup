package tc600s.tc627;
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class HappyLetterDiv1
{
	public String getHappyLetters(String letters)
	{
		String ret = "";
		int len = letters.length();
		int[] c = new int[26]; // c[char] = count
		
		for (int i=0; i<len; i++) {
			c[(int) letters.charAt(i) - 97] += 1;
		}
		
		for (int i=0; i<c.length; i++) {
			if (c[i] == 0) continue;
			int[] tempc = new int[26];
			for (int j = 0; j < c.length; j++) {
				tempc[j] = c[j];
			}
			
			while (tempc[i] != 0) {
				int max = 0;
				int maxpos = -1;
				for (int j=0; j<c.length; j++) {
					if (j != i && tempc[j] > max) {
						max = tempc[j];
						maxpos = j;
					}
				}
				if (maxpos == -1) {
					ret += (char) (i + 97);
					break;
				}
				
				int max2 = 0;
				int max2pos = -1;
				for (int j=0; j<c.length; j++) {
					if (j != i && j != maxpos && tempc[j] > max2) {
						max2 = tempc[j];
						max2pos = j;
					}
				}
				if (max2pos == -1) max2pos = i;
				tempc[maxpos]--;
				tempc[max2pos]--;
			}

		}
		
		return ret;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit-pf 2.3.0
	private static boolean KawigiEdit_RunTest(int testNum, String p0, boolean hasAnswer, String p1) {
		System.out.print("Test " + testNum + ": [" + "\"" + p0 + "\"");
		System.out.println("]");
		HappyLetterDiv1 obj;
		String answer;
		obj = new HappyLetterDiv1();
		long startTime = System.currentTimeMillis();
		answer = obj.getHappyLetters(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + "\"" + p1 + "\"");
		}
		System.out.println("Your answer:");
		System.out.println("\t" + "\"" + answer + "\"");
		if (hasAnswer) {
			res = answer.equals(p1);
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		boolean disabled;
		boolean tests_disabled;
		all_right = true;
		tests_disabled = false;
		
		String p0;
		String p1;
		
		// ----- test 0 -----
		disabled = false;
		p0 = "aabbacccc";
		p1 = "abc";
		all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 1 -----
		disabled = false;
		p0 = "aaaaaaaccdd";
		p1 = "a";
		all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 2 -----
		disabled = false;
		p0 = "ddabccadb";
		p1 = "abcd";
		all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 3 -----
		disabled = false;
		p0 = "aaabbb";
		p1 = "";
		all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 4 -----
		disabled = false;
		p0 = "rdokcogscosn";
		p1 = "cos";
		all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		if (all_right) {
			if (tests_disabled) {
				System.out.println("You're a stud (but some test cases were disabled)!");
			} else {
				System.out.println("You're a stud (at least on given cases)!");
			}
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// The Happy Letter game is played as follows:
	// At the beginning, several players enter the field.
	// Each player has a lowercase English letter on their back.
	// The game is played in turns.
	// In each turn, you select two players with different letters, and both selected players leave the field.
	// The game ends once it is impossible to take another turn.
	// 
	// If there are some players left in the field at the end of the game, they must all have the same letter.
	// That letter is called the winning letter.
	// If there are no players left in the field at the end of the game, there is no winning letter.
	// 
	// You are given a String letters.
	// The characters in letters are the characters carried by the players at the beginning of the game.
	// Return a String with all possible winning letters.
	// The letters in the returned String must be sorted in increasing order.
	// 
	// 
	// DEFINITION
	// Class:HappyLetterDiv1
	// Method:getHappyLetters
	// Parameters:String
	// Returns:String
	// Method signature:String getHappyLetters(String letters)
	// 
	// 
	// NOTES
	// -If there's no happy letter, return the empty String.
	// 
	// 
	// CONSTRAINTS
	// -letters will contain between 1 and 50 elements.
	// -Each element of letters will be a lowercase English letter ('a'-'z').
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// "aabbacccc"
	// 
	// Returns: "abc"
	// 
	// Each of the three letters can be the winning letter.
	// Here is one possibility how 'a' can be the winning letter:
	// Let's number the players 0 through 8 in the order in which they appear in the input.
	// We can then play the game as follows:
	// 
	// Send away players 1 ('a') and 8 ('c').
	// Send away players 2 ('b') and 6 ('c').
	// Send away players 7 ('c') and 0 ('a').
	// Send away players 5 ('c') and 3 ('b').
	// The only player left is player 4 ('a'), hence 'a' is the winning letter.
	// 
	// 
	// 
	// 1)
	// "aaaaaaaccdd"
	// 
	// Returns: "a"
	// 
	// Only letter 'a' can win.
	// 
	// 2)
	// "ddabccadb"
	// 
	// Returns: "abcd"
	// 
	// 
	// 
	// 3)
	// "aaabbb"
	// 
	// Returns: ""
	// 
	// No letter can win.
	// 
	// 
	// 4)
	// "rdokcogscosn"
	// 
	// Returns: "cos"
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}

//Powered by KawigiEdit-pf 2.3.0!
