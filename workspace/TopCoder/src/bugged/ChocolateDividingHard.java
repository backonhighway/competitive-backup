package bugged;
import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;

//bugged 636div2
public class ChocolateDividingHard
{
	int[][] cum;
	int ylen;
	int xlen;
	String[] chocolate;
	
	public int findBest(String[] chocolate)
	{
		this.chocolate = chocolate;
		this.ylen = chocolate.length;
		this.xlen = chocolate[0].length();
		
		// precalculate
		this.cum = new int[ylen][xlen];
		for (int i=0; i<ylen; i++) {
			int htotal = 0;
			for (int j=0; j<xlen; j++) {
				htotal += getInt(chocolate[i].charAt(j));
				cum[i][j] += htotal;

				if (i != 0) {
					cum[i][j] += cum[i-1][j];
				}
			}
		}
		
		int lo = 0; //include
		int hi = 9 * xlen * ylen + 1; //exlude
		int mid = lo;
		while (lo + 1 < hi) {
			mid = lo + (hi - lo) / 2;
			if (isPossible(mid)) { //check() should return true if mid includes (mid is valid)
				lo = mid;
			} else {
				hi = mid;
			}
		}
		return lo;
		
	}
	
	public boolean isPossible(int r) {
		for (int x1 = 0; x1 < xlen; x1++) {
			for (int x2 = 0; x2 < xlen; x2++) {
				for (int x3 = 0; x3 < xlen; x3++) {
					int[] x = {x1, x2, x3};
					
					//bin search the minimum y-cut
					int lo = 1; //include
					int hi = ylen; //exlude
					int mid = lo;
					while (lo + 1 < hi) {
						mid = lo + (hi - lo) / 2;
						if (check(0, mid, x, r)) { //check() should return true if mid includes (mid is valid)
							lo = mid;
						} else {
							hi = mid;
						}
					} //answer is in lo
					if (lo >= ylen-2) continue;
					
					//bin search the minimum y2-cut
					int ytop = lo + 1;
					lo = ytop; //include
					hi = ylen; //exlude
					mid = lo;
					while (lo + 1 < hi) {
						mid = lo + (hi - lo) / 2;
						if (check(ytop, mid, x, r)) { //check() should return true if mid includes (mid is valid)
							lo = mid;
						} else {
							hi = mid;
						}
					} //answer is in lo
					if (lo >= ylen-1) continue;
					
					//if y3 is ok?
					if (check(lo+1, ylen-1, x, r)) return true;
				}
			}
		}
		
		return false;
	}
	
	public boolean check(int ytop, int ybot, int[]x, int r) {
		//left
		int lsum = cum[ybot][x[0]];
		if (ytop != 0) lsum -= cum[ytop][x[0]];
		
		//middle
		int msum = cum[ybot][x[1]];
		if (ytop != 0) msum -= cum[ytop][x[1]];
		msum -= lsum;
		
		//right
		int rsum = cum[ybot][x[1]];
		if (ytop != 0) rsum -= cum[ytop][x[1]];
		rsum -= lsum;
		
		
		return lsum >= r && msum >= r && rsum >= r;
	}
	
	public int getInt(char c) {
		return c - '0';
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit-pf 2.3.0
	private static boolean KawigiEdit_RunTest(int testNum, String[] p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print("\"" + p0[i] + "\"");
		}
		System.out.print("}");
		System.out.println("]");
		ChocolateDividingHard obj;
		int answer;
		obj = new ChocolateDividingHard();
		long startTime = System.currentTimeMillis();
		answer = obj.findBest(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		boolean disabled;
		boolean tests_disabled;
		all_right = true;
		tests_disabled = false;
		
		String[] p0;
		int p1;
		
		// ----- test 0 -----
		disabled = false;
		p0 = new String[]{"95998","21945","23451","99798","74083"};
		p1 = 3;
		all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 1 -----
		disabled = false;
		p0 = new String[]{"12942","23456","99798","98998","67675"};
		p1 = 5;
		all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 2 -----
		disabled = false;
		p0 = new String[]{"129420","234560","997980","989980","676760"};
		p1 = 6;
		all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		// ----- test 3 -----
		disabled = false;
		p0 = new String[]{"75356291270936062","61879202375922897","36129319478450361","06320615547656937","45254744307868843","14920689266495048","71727226106159490","91771159776736563","94812939088509638","56115984810304444","76317596217857418","59753883189643338"};
		p1 = 44;
		all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
		tests_disabled = tests_disabled || disabled;
		// ------------------
		
		if (all_right) {
			if (tests_disabled) {
				System.out.println("You're a stud (but some test cases were disabled)!");
			} else {
				System.out.println("You're a stud (at least on given cases)!");
			}
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Mirosz adores sweets.
	// He has just bought a rectangular bar of chocolate.
	// The bar is divided into a grid of square cells.
	// Different cells may have a different quality.
	// You are given the description of the bar in a String[] chocolate.
	// Each character in chocolate is a digit between '0' and '9', inclusive: the quality of one of the cells.
	// 
	// Mirosz is now going to divide the chocolate into 16 parts: one for him and one for each of his 15 friends.
	// He will do the division by making six cuts: three horizontal and three vertical ones.
	// Each cut must go between two rows or columns of cells.
	// Each of the 16 parts must be non-empty.
	// The quality of a part is the sum of the qualities of all cells it contains.
	// 
	// Mirosz is well-mannered and he will let his friends choose their pieces first.
	// His friends are even more addicted to chocolate than he is.
	// Therefore, they will certainly choose the pieces with higher quality first, and Mirosz will be left with the worst of the 16 pieces.
	// 
	// You are given the String[] chocolate.
	// Find the optimal places for the six cuts.
	// More precisely, compute and return the largest possible quality of Mirosz's part of the chocolate bar.
	// 
	// DEFINITION
	// Class:ChocolateDividingHard
	// Method:findBest
	// Parameters:String[]
	// Returns:int
	// Method signature:int findBest(String[] chocolate)
	// 
	// 
	// CONSTRAINTS
	// -chocolate will contain between 4 and 75 elements, inclusive. 
	// -All elements in chocolate will contain between 4 and 75 characters, inclusive. 
	// -All elements in chocolate will contain the same number of characters. 
	// -All elements in chocolate will contain only digits.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {
	// "95998",
	// "21945",
	// "23451",
	// "99798",
	// "74083"
	// }
	// 
	// Returns: 3
	// 
	// One of two optimal ways to cut this chocolate is shown below. 
	// 
	// 9 | 5 | 9 9 | 8 
	// --|---|-----|--- 
	// 2 | 1 | 9 4 | 5 
	// 2 | 3 | 4 5 | 1 
	// --|---|-----|--- 
	// 9 | 9 | 7 9 | 8 
	// --|---|-----|--- 
	// 7 | 4 | 0 8 | 3 
	// 
	// This way of cutting produces parts with the following qualities: 9, 5, 18, 8, 4, 4, 22, 6, 9, 9, 16, 8, 7, 4, 8, 3. The quality of the worst part (the one that Mirosz will get) is 3. 
	// 
	// Here is another way of cutting the same chocolate: 
	// 
	// 9 | 5 9 | 9 | 8 
	// --|-----|---|--- 
	// 2 | 1 9 | 4 | 5 
	// --|-----|---|--- 
	// 2 | 3 4 | 5 | 1 
	// 9 | 9 7 | 9 | 8 
	// --|-----|---|--- 
	// 7 | 4 0 | 8 | 3  
	// 
	// If Mirosz cuts the chocolate in this way, the quality of his part will be 2, which is worse than 3.
	// 
	// 1)
	// {
	// "12942",
	// "23456",
	// "99798",
	// "98998",
	// "67675"
	// }
	// 
	// Returns: 5
	// 
	// 
	// 
	// 2)
	// {
	// "129420",
	// "234560",
	// "997980",
	// "989980",
	// "676760"
	// }
	// 
	// Returns: 6
	// 
	// 
	// 
	// 3)
	// {"75356291270936062","61879202375922897","36129319478450361","06320615547656937","45254744307868843","14920689266495048","71727226106159490","91771159776736563","94812939088509638","56115984810304444","76317596217857418","59753883189643338"}
	// 
	// Returns: 44
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}

//Powered by KawigiEdit-pf 2.3.0!
